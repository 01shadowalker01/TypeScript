=== tests/cases/conformance/types/tuple/tupleSpreadCall.ts ===
declare let singleton: [number]
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

declare let pair: [number, number]
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

declare let wpair: [number, string]
>wpair : Symbol(wpair, Decl(tupleSpreadCall.ts, 2, 11))

declare let triple: [number, number, number]
>triple : Symbol(triple, Decl(tupleSpreadCall.ts, 3, 11))

declare let ns: number[]
>ns : Symbol(ns, Decl(tupleSpreadCall.ts, 4, 11))

declare function two(n: number, m: number): void;
>two : Symbol(two, Decl(tupleSpreadCall.ts, 4, 24))
>n : Symbol(n, Decl(tupleSpreadCall.ts, 5, 21))
>m : Symbol(m, Decl(tupleSpreadCall.ts, 5, 31))

declare function three(n: number, m: number, total: number): void;
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>n : Symbol(n, Decl(tupleSpreadCall.ts, 6, 23))
>m : Symbol(m, Decl(tupleSpreadCall.ts, 6, 33))
>total : Symbol(total, Decl(tupleSpreadCall.ts, 6, 44))

declare function opt2(n: number, m?: number): void;
>opt2 : Symbol(opt2, Decl(tupleSpreadCall.ts, 6, 66))
>n : Symbol(n, Decl(tupleSpreadCall.ts, 7, 22))
>m : Symbol(m, Decl(tupleSpreadCall.ts, 7, 32))

declare function opt3(n: number, m: number, total?: number): void;
>opt3 : Symbol(opt3, Decl(tupleSpreadCall.ts, 7, 51))
>n : Symbol(n, Decl(tupleSpreadCall.ts, 8, 22))
>m : Symbol(m, Decl(tupleSpreadCall.ts, 8, 32))
>total : Symbol(total, Decl(tupleSpreadCall.ts, 8, 43))

declare function rest(n: number, ...ns: number[]): void;
>rest : Symbol(rest, Decl(tupleSpreadCall.ts, 8, 66))
>n : Symbol(n, Decl(tupleSpreadCall.ts, 9, 22))
>ns : Symbol(ns, Decl(tupleSpreadCall.ts, 9, 32))

declare function rest2(n: number, m: number, ...ns: number[]): void;
>rest2 : Symbol(rest2, Decl(tupleSpreadCall.ts, 9, 56))
>n : Symbol(n, Decl(tupleSpreadCall.ts, 10, 23))
>m : Symbol(m, Decl(tupleSpreadCall.ts, 10, 33))
>ns : Symbol(ns, Decl(tupleSpreadCall.ts, 10, 44))

type First = { first }
>First : Symbol(First, Decl(tupleSpreadCall.ts, 10, 68))
>first : Symbol(first, Decl(tupleSpreadCall.ts, 12, 14))

type Second = { second }
>Second : Symbol(Second, Decl(tupleSpreadCall.ts, 12, 22))
>second : Symbol(second, Decl(tupleSpreadCall.ts, 13, 15))

declare function onetwo(n: number): First;
>onetwo : Symbol(onetwo, Decl(tupleSpreadCall.ts, 13, 24), Decl(tupleSpreadCall.ts, 14, 42))
>n : Symbol(n, Decl(tupleSpreadCall.ts, 14, 24))
>First : Symbol(First, Decl(tupleSpreadCall.ts, 10, 68))

declare function onetwo(n: number, m: number): Second;
>onetwo : Symbol(onetwo, Decl(tupleSpreadCall.ts, 13, 24), Decl(tupleSpreadCall.ts, 14, 42))
>n : Symbol(n, Decl(tupleSpreadCall.ts, 15, 24))
>m : Symbol(m, Decl(tupleSpreadCall.ts, 15, 34))
>Second : Symbol(Second, Decl(tupleSpreadCall.ts, 12, 22))

declare function optwothree(n: number, m?: number): First;
>optwothree : Symbol(optwothree, Decl(tupleSpreadCall.ts, 15, 54), Decl(tupleSpreadCall.ts, 17, 58))
>n : Symbol(n, Decl(tupleSpreadCall.ts, 17, 28))
>m : Symbol(m, Decl(tupleSpreadCall.ts, 17, 38))
>First : Symbol(First, Decl(tupleSpreadCall.ts, 10, 68))

declare function optwothree(n: number, m: number, total?: number): Second;
>optwothree : Symbol(optwothree, Decl(tupleSpreadCall.ts, 15, 54), Decl(tupleSpreadCall.ts, 17, 58))
>n : Symbol(n, Decl(tupleSpreadCall.ts, 18, 28))
>m : Symbol(m, Decl(tupleSpreadCall.ts, 18, 38))
>total : Symbol(total, Decl(tupleSpreadCall.ts, 18, 49))
>Second : Symbol(Second, Decl(tupleSpreadCall.ts, 12, 22))

two(...pair)
>two : Symbol(two, Decl(tupleSpreadCall.ts, 4, 24))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

two(...wpair) // wrong type
>two : Symbol(two, Decl(tupleSpreadCall.ts, 4, 24))
>wpair : Symbol(wpair, Decl(tupleSpreadCall.ts, 2, 11))

three(1, ...pair)
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

three(1, ...wpair) // wrong type
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>wpair : Symbol(wpair, Decl(tupleSpreadCall.ts, 2, 11))

three(...pair, 1)
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

three(...wpair, 1) // wrong type
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>wpair : Symbol(wpair, Decl(tupleSpreadCall.ts, 2, 11))

// multiple spreads
three(...singleton, ...pair);
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

three(...pair, ...singleton);
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

three(12, ...singleton, ...singleton);
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

three(...singleton, 12, ...singleton);
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

three(...singleton, ...singleton, 12);
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

three(...wpair, ...singleton); // wrong type
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>wpair : Symbol(wpair, Decl(tupleSpreadCall.ts, 2, 11))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

three(...pair, ...pair); // Expected 3, got 4
>three : Symbol(three, Decl(tupleSpreadCall.ts, 5, 49))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

// optionals (exact and inexact)
opt2(...pair);
>opt2 : Symbol(opt2, Decl(tupleSpreadCall.ts, 6, 66))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

opt2(1, ...singleton);
>opt2 : Symbol(opt2, Decl(tupleSpreadCall.ts, 6, 66))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

opt2(...pair, 1); // Expected 1-2, got 3
>opt2 : Symbol(opt2, Decl(tupleSpreadCall.ts, 6, 66))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

opt2(...singleton);
>opt2 : Symbol(opt2, Decl(tupleSpreadCall.ts, 6, 66))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

opt3(...singleton); // Expected 2-3, got 1
>opt3 : Symbol(opt3, Decl(tupleSpreadCall.ts, 7, 51))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

opt3(...singleton, ...pair);
>opt3 : Symbol(opt3, Decl(tupleSpreadCall.ts, 7, 51))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

// OK: arrays of any length are spreadable into optional arguments
opt2(...triple);
>opt2 : Symbol(opt2, Decl(tupleSpreadCall.ts, 6, 66))
>triple : Symbol(triple, Decl(tupleSpreadCall.ts, 3, 11))

opt2(1, ...pair);
>opt2 : Symbol(opt2, Decl(tupleSpreadCall.ts, 6, 66))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

opt3(...singleton, 2, ...triple);
>opt3 : Symbol(opt3, Decl(tupleSpreadCall.ts, 7, 51))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>triple : Symbol(triple, Decl(tupleSpreadCall.ts, 3, 11))

opt3(2, ...triple);
>opt3 : Symbol(opt3, Decl(tupleSpreadCall.ts, 7, 51))
>triple : Symbol(triple, Decl(tupleSpreadCall.ts, 3, 11))

opt3(2, ...singleton, ...triple);
>opt3 : Symbol(opt3, Decl(tupleSpreadCall.ts, 7, 51))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>triple : Symbol(triple, Decl(tupleSpreadCall.ts, 3, 11))

opt3(2, 3, ...triple);
>opt3 : Symbol(opt3, Decl(tupleSpreadCall.ts, 7, 51))
>triple : Symbol(triple, Decl(tupleSpreadCall.ts, 3, 11))

opt3(...singleton, 2, ...ns);
>opt3 : Symbol(opt3, Decl(tupleSpreadCall.ts, 7, 51))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>ns : Symbol(ns, Decl(tupleSpreadCall.ts, 4, 11))

opt3(2, ...singleton, ...ns);
>opt3 : Symbol(opt3, Decl(tupleSpreadCall.ts, 7, 51))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>ns : Symbol(ns, Decl(tupleSpreadCall.ts, 4, 11))

//calls with rests (exact and inexact)
rest(...pair);
>rest : Symbol(rest, Decl(tupleSpreadCall.ts, 8, 66))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

rest(1, ...pair);
>rest : Symbol(rest, Decl(tupleSpreadCall.ts, 8, 66))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

rest2(...singleton); // Expected at least 2, got 1
>rest2 : Symbol(rest2, Decl(tupleSpreadCall.ts, 9, 56))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

rest2(...singleton, ...singleton);
>rest2 : Symbol(rest2, Decl(tupleSpreadCall.ts, 9, 56))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

rest2(...singleton, ...singleton, ...singleton);
>rest2 : Symbol(rest2, Decl(tupleSpreadCall.ts, 9, 56))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

rest2(...singleton, ...singleton, ...triple);
>rest2 : Symbol(rest2, Decl(tupleSpreadCall.ts, 9, 56))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))
>triple : Symbol(triple, Decl(tupleSpreadCall.ts, 3, 11))

// overloads
declare var first: First;
>first : Symbol(first, Decl(tupleSpreadCall.ts, 66, 11), Decl(tupleSpreadCall.ts, 68, 3), Decl(tupleSpreadCall.ts, 72, 3), Decl(tupleSpreadCall.ts, 73, 3), Decl(tupleSpreadCall.ts, 74, 3) ... and 1 more)
>First : Symbol(First, Decl(tupleSpreadCall.ts, 10, 68))

declare var second: Second;
>second : Symbol(second, Decl(tupleSpreadCall.ts, 67, 11), Decl(tupleSpreadCall.ts, 69, 3), Decl(tupleSpreadCall.ts, 70, 3), Decl(tupleSpreadCall.ts, 75, 3))
>Second : Symbol(Second, Decl(tupleSpreadCall.ts, 12, 22))

var first = onetwo(...singleton);
>first : Symbol(first, Decl(tupleSpreadCall.ts, 66, 11), Decl(tupleSpreadCall.ts, 68, 3), Decl(tupleSpreadCall.ts, 72, 3), Decl(tupleSpreadCall.ts, 73, 3), Decl(tupleSpreadCall.ts, 74, 3) ... and 1 more)
>onetwo : Symbol(onetwo, Decl(tupleSpreadCall.ts, 13, 24), Decl(tupleSpreadCall.ts, 14, 42))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

var second = onetwo(...pair);
>second : Symbol(second, Decl(tupleSpreadCall.ts, 67, 11), Decl(tupleSpreadCall.ts, 69, 3), Decl(tupleSpreadCall.ts, 70, 3), Decl(tupleSpreadCall.ts, 75, 3))
>onetwo : Symbol(onetwo, Decl(tupleSpreadCall.ts, 13, 24), Decl(tupleSpreadCall.ts, 14, 42))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

var second = onetwo(...triple); // Expected 1-2, got 3
>second : Symbol(second, Decl(tupleSpreadCall.ts, 67, 11), Decl(tupleSpreadCall.ts, 69, 3), Decl(tupleSpreadCall.ts, 70, 3), Decl(tupleSpreadCall.ts, 75, 3))
>onetwo : Symbol(onetwo, Decl(tupleSpreadCall.ts, 13, 24), Decl(tupleSpreadCall.ts, 14, 42))
>triple : Symbol(triple, Decl(tupleSpreadCall.ts, 3, 11))

var first = optwothree(...singleton);
>first : Symbol(first, Decl(tupleSpreadCall.ts, 66, 11), Decl(tupleSpreadCall.ts, 68, 3), Decl(tupleSpreadCall.ts, 72, 3), Decl(tupleSpreadCall.ts, 73, 3), Decl(tupleSpreadCall.ts, 74, 3) ... and 1 more)
>optwothree : Symbol(optwothree, Decl(tupleSpreadCall.ts, 15, 54), Decl(tupleSpreadCall.ts, 17, 58))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

var first = optwothree(...pair);
>first : Symbol(first, Decl(tupleSpreadCall.ts, 66, 11), Decl(tupleSpreadCall.ts, 68, 3), Decl(tupleSpreadCall.ts, 72, 3), Decl(tupleSpreadCall.ts, 73, 3), Decl(tupleSpreadCall.ts, 74, 3) ... and 1 more)
>optwothree : Symbol(optwothree, Decl(tupleSpreadCall.ts, 15, 54), Decl(tupleSpreadCall.ts, 17, 58))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

var first = optwothree(...pair, ...singleton);
>first : Symbol(first, Decl(tupleSpreadCall.ts, 66, 11), Decl(tupleSpreadCall.ts, 68, 3), Decl(tupleSpreadCall.ts, 72, 3), Decl(tupleSpreadCall.ts, 73, 3), Decl(tupleSpreadCall.ts, 74, 3) ... and 1 more)
>optwothree : Symbol(optwothree, Decl(tupleSpreadCall.ts, 15, 54), Decl(tupleSpreadCall.ts, 17, 58))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))
>singleton : Symbol(singleton, Decl(tupleSpreadCall.ts, 0, 11))

var second = optwothree(...pair, 1);
>second : Symbol(second, Decl(tupleSpreadCall.ts, 67, 11), Decl(tupleSpreadCall.ts, 69, 3), Decl(tupleSpreadCall.ts, 70, 3), Decl(tupleSpreadCall.ts, 75, 3))
>optwothree : Symbol(optwothree, Decl(tupleSpreadCall.ts, 15, 54), Decl(tupleSpreadCall.ts, 17, 58))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

var first = optwothree(...pair, ...pair);
>first : Symbol(first, Decl(tupleSpreadCall.ts, 66, 11), Decl(tupleSpreadCall.ts, 68, 3), Decl(tupleSpreadCall.ts, 72, 3), Decl(tupleSpreadCall.ts, 73, 3), Decl(tupleSpreadCall.ts, 74, 3) ... and 1 more)
>optwothree : Symbol(optwothree, Decl(tupleSpreadCall.ts, 15, 54), Decl(tupleSpreadCall.ts, 17, 58))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))
>pair : Symbol(pair, Decl(tupleSpreadCall.ts, 1, 11))

optwothree(...triple, 1); // expected 1-3, got 4
>optwothree : Symbol(optwothree, Decl(tupleSpreadCall.ts, 15, 54), Decl(tupleSpreadCall.ts, 17, 58))
>triple : Symbol(triple, Decl(tupleSpreadCall.ts, 3, 11))

// TODO: generics

