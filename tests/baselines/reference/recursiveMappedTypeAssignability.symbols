=== tests/cases/compiler/recursiveMappedTypeAssignability.ts ===
// type D<U> = { [P in keyof U]: D<U[P]> };
// <T>(t: T, dt: D<T>) => { dt = t };
// type DR<U> = { readonly [P in keyof U]: DR<U[P]> };
// <T>(t: T, dt: DR<T>) => { dt = t };
// type DP<U> = { [P in keyof U]?: DP<U[P]> };
// <T>(t: T, dt: DP<T>) => { dt = t };
// type DAP<U> = { [P in keyof U]?: DAP<U[P]> & U[P] };
// <T>(t: T, dt: DAP<T>) => { dt = t };

// #21592
// doesn't work because aliasSymbol isn't set on the literal type
// since it's not top-level -- the union is.
type SafeAny<T> = {
>SafeAny : Symbol(SafeAny, Decl(recursiveMappedTypeAssignability.ts, 0, 0))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 12, 13))

    [K in keyof T]?: SafeAny<T[K]>
>K : Symbol(K, Decl(recursiveMappedTypeAssignability.ts, 13, 5))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 12, 13))
>SafeAny : Symbol(SafeAny, Decl(recursiveMappedTypeAssignability.ts, 0, 0))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 12, 13))
>K : Symbol(K, Decl(recursiveMappedTypeAssignability.ts, 13, 5))

} | boolean | number | string | symbol | null | undefined
type DataValidator<T> = {
>DataValidator : Symbol(DataValidator, Decl(recursiveMappedTypeAssignability.ts, 14, 57))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 15, 19))

    [K in keyof T]?: (v: SafeAny<T[K]>) => v is T[K]
>K : Symbol(K, Decl(recursiveMappedTypeAssignability.ts, 16, 5))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 15, 19))
>v : Symbol(v, Decl(recursiveMappedTypeAssignability.ts, 16, 22))
>SafeAny : Symbol(SafeAny, Decl(recursiveMappedTypeAssignability.ts, 0, 0))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 15, 19))
>K : Symbol(K, Decl(recursiveMappedTypeAssignability.ts, 16, 5))
>v : Symbol(v, Decl(recursiveMappedTypeAssignability.ts, 16, 22))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 15, 19))
>K : Symbol(K, Decl(recursiveMappedTypeAssignability.ts, 16, 5))
}

// modified repro with top-level mapped type, which works
// because the literal type has aliasSymbol set
type SafeAnyMap<T> = {
>SafeAnyMap : Symbol(SafeAnyMap, Decl(recursiveMappedTypeAssignability.ts, 17, 1))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 21, 16))

    [K in keyof T]?: SafeAny2<T[K]>
>K : Symbol(K, Decl(recursiveMappedTypeAssignability.ts, 22, 5))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 21, 16))
>SafeAny2 : Symbol(SafeAny2, Decl(recursiveMappedTypeAssignability.ts, 23, 1))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 21, 16))
>K : Symbol(K, Decl(recursiveMappedTypeAssignability.ts, 22, 5))
}
type SafeAny2<T> = SafeAnyMap<T> | boolean | number | string | symbol | null | undefined
>SafeAny2 : Symbol(SafeAny2, Decl(recursiveMappedTypeAssignability.ts, 23, 1))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 24, 14))
>SafeAnyMap : Symbol(SafeAnyMap, Decl(recursiveMappedTypeAssignability.ts, 17, 1))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 24, 14))

<T>(t: T, sat: SafeAny2<T>) => { sat = t }
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 25, 1))
>t : Symbol(t, Decl(recursiveMappedTypeAssignability.ts, 25, 4))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 25, 1))
>sat : Symbol(sat, Decl(recursiveMappedTypeAssignability.ts, 25, 9))
>SafeAny2 : Symbol(SafeAny2, Decl(recursiveMappedTypeAssignability.ts, 23, 1))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 25, 1))
>sat : Symbol(sat, Decl(recursiveMappedTypeAssignability.ts, 25, 9))
>t : Symbol(t, Decl(recursiveMappedTypeAssignability.ts, 25, 4))


const fn = <T>(arg: T) => {
>fn : Symbol(fn, Decl(recursiveMappedTypeAssignability.ts, 28, 5))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 28, 12))
>arg : Symbol(arg, Decl(recursiveMappedTypeAssignability.ts, 28, 15))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 28, 12))

    ((arg2: RecursivePartial<T>) => {
>arg2 : Symbol(arg2, Decl(recursiveMappedTypeAssignability.ts, 29, 6))
>RecursivePartial : Symbol(RecursivePartial, Decl(recursiveMappedTypeAssignability.ts, 32, 2))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 28, 12))

        // ...
    })(arg);
>arg : Symbol(arg, Decl(recursiveMappedTypeAssignability.ts, 28, 15))

};

type RecursivePartial<T> = {
>RecursivePartial : Symbol(RecursivePartial, Decl(recursiveMappedTypeAssignability.ts, 32, 2))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 34, 22))

    [P in keyof T]?: RecursivePartial<T[P]>;
>P : Symbol(P, Decl(recursiveMappedTypeAssignability.ts, 35, 5))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 34, 22))
>RecursivePartial : Symbol(RecursivePartial, Decl(recursiveMappedTypeAssignability.ts, 32, 2))
>T : Symbol(T, Decl(recursiveMappedTypeAssignability.ts, 34, 22))
>P : Symbol(P, Decl(recursiveMappedTypeAssignability.ts, 35, 5))

};

