=== tests/cases/conformance/types/match/matchGenericTypeArgument.ts ===
// all of these test `match` with generics.

// empty
type A<T> = T match {
>A : never
>T : T
>T : T

};
declare const A1: A<1>;
>A1 : never
>A : never

declare const A1or2: A<1 | 2>;
>A1or2 : never
>A : never

declare const Astring: A<"">;
>Astring : never
>A : never

declare const Aempty: A<{}>;
>Aempty : never
>A : never

declare const Anever: A<never>;
>Anever : never
>A : never

declare const Aany: A<any>;
>Aany : never
>A : never

declare const Aundefined: A<undefined>;
>Aundefined : never
>A : never

// only else
type B<T> = T match {
>B : "else"
>T : T
>T : T

    else: "else"
};
declare const B1: B<1>;
>B1 : "else"
>B : "else"

declare const B1or2: B<1 | 2>;
>B1or2 : "else"
>B : "else"

declare const Bstring: B<"">;
>Bstring : "else"
>B : "else"

declare const Bempty: B<{}>;
>Bempty : "else"
>B : "else"

declare const Bnever: B<never>;
>Bnever : "else"
>B : "else"

declare const Bany: B<any>;
>Bany : "else"
>B : "else"

declare const Bundefined: B<undefined>;
>Bundefined : "else"
>B : "else"

// only one exact match, no else
type C<T> = T match {
>C : C<T>
>T : T
>T : T

    1: "1"
};
declare const C1: C<1>;
>C1 : "1"
>C : C<T>

declare const C1or2: C<1 | 2>;
>C1or2 : "1"
>C : C<T>

declare const Cstring: C<"">;
>Cstring : never
>C : C<T>

declare const Cempty: C<{}>;
>Cempty : never
>C : C<T>

declare const Cnever: C<never>;
>Cnever : "1"
>C : C<T>

declare const Cany: C<any>;
>Cany : "1"
>C : C<T>

declare const Cundefined: C<undefined>;
>Cundefined : "1"
>C : C<T>

// only one subtype match, no else
type D<T> = T match {
>D : D<T>
>T : T
>T : T

    number: "number"
};
declare const D1: D<1>;
>D1 : "number"
>D : D<T>

declare const D1or2: D<1 | 2>;
>D1or2 : "number"
>D : D<T>

declare const Dstring: D<"">;
>Dstring : never
>D : D<T>

declare const Dempty: D<{}>;
>Dempty : never
>D : D<T>

declare const Dnever: D<never>;
>Dnever : "number"
>D : D<T>

declare const Dany: D<any>;
>Dany : "number"
>D : D<T>

declare const Dundefined: D<undefined>;
>Dundefined : "number"
>D : D<T>

// multiple possible subtype matches, no else
type E<T> = T match {
>E : E<T>
>T : T
>T : T

    1 | 2: "1 | 2",
    number: "number"
};
declare const E1: E<1>;
>E1 : "1 | 2"
>E : E<T>

declare const E1or2: E<1 | 2>;
>E1or2 : "1 | 2"
>E : E<T>

declare const E3: E<3>;
>E3 : "number"
>E : E<T>

declare const Estring: E<"">;
>Estring : never
>E : E<T>

declare const Eempty: E<{}>;
>Eempty : never
>E : E<T>

declare const Enever: E<never>;
>Enever : "1 | 2"
>E : E<T>

declare const Eany: E<any>;
>Eany : "1 | 2"
>E : E<T>

declare const Eundefined: E<undefined>;
>Eundefined : "1 | 2"
>E : E<T>

// multiple possible matches (subtype first), no else
type F<T> = T match {
>F : F<T>
>T : T
>T : T

    1 | 2: "1 | 2",
    1: "1",
    number: "number"
};
declare const F1: F<1>;
>F1 : "1 | 2"
>F : F<T>

declare const F1or2: F<1 | 2>;
>F1or2 : "1 | 2"
>F : F<T>

declare const F2or3: F<2 | 3>;
>F2or3 : "number" | "1 | 2"
>F : F<T>

declare const F3: F<3>;
>F3 : "number"
>F : F<T>

declare const Fstring: F<"">;
>Fstring : never
>F : F<T>

declare const Fempty: F<{}>;
>Fempty : never
>F : F<T>

declare const Fnever: F<never>;
>Fnever : "1 | 2"
>F : F<T>

declare const Fany: F<any>;
>Fany : "1 | 2"
>F : F<T>

declare const Fundefined: F<undefined>;
>Fundefined : "1 | 2"
>F : F<T>

// never
type G<T> = T match {
>G : G<T>
>T : T
>T : T

    never: "never",
    number: "number",
    else: "else"
};
declare const G1: G<1>;
>G1 : "number"
>G : G<T>

declare const G1or2: G<1 | 2>;
>G1or2 : "number"
>G : G<T>

declare const Gstring: G<"">;
>Gstring : "else"
>G : G<T>

declare const Gempty: G<{}>;
>Gempty : "else"
>G : G<T>

declare const Gnever: G<never>;
>Gnever : "never"
>G : G<T>

declare const Gany: G<any>;
>Gany : "number"
>G : G<T>

declare const Gundefined: G<undefined>;
>Gundefined : "number"
>G : G<T>

// undefined
type H<T> = T match {
>H : H<T>
>T : T
>T : T

    undefined: "undefined",
    number: "number",
    else: "else"
};
declare const H1: H<1>;
>H1 : "number"
>H : H<T>

declare const H1or2: H<1 | 2>;
>H1or2 : "number"
>H : H<T>

declare const Hstring: H<"">;
>Hstring : "else"
>H : H<T>

declare const Hempty: H<{}>;
>Hempty : "else"
>H : H<T>

declare const Hnever: H<never>;
>Hnever : "undefined"
>H : H<T>

declare const Hany: H<any>;
>Hany : "undefined"
>H : H<T>

declare const Hundefined: H<undefined>;
>Hundefined : "undefined"
>H : H<T>

// union, both match, no else
type I<T, U> = (T | U) match {
>I : I<T, U>
>T : T
>U : U
>T : T
>U : U

    1: "1",
    2: "2"
};
declare const I11: I<1, 1>;
>I11 : "1"
>I : I<T, U>

declare const I12: I<1, 2>;
>I12 : "1" | "2"
>I : I<T, U>

declare const I11or2: I<1, 1 | 2>;
>I11or2 : "1" | "2"
>I : I<T, U>

declare const I1string: I<1, "">;
>I1string : "1"
>I : I<T, U>

declare const I1empty: I<1, {}>;
>I1empty : "1"
>I : I<T, U>

declare const I1never: I<1, never>;
>I1never : "1"
>I : I<T, U>

declare const I1any: I<1, any>;
>I1any : "1"
>I : I<T, U>

declare const I1undefined: I<1, undefined>;
>I1undefined : "1"
>I : I<T, U>

// union, one match, no else
type J<T, U> = (T | U) match {
>J : J<T, U>
>T : T
>U : U
>T : T
>U : U

    1: "1"
};
declare const J11: J<1, 1>;
>J11 : "1"
>J : J<T, U>

declare const J12: J<1, 2>;
>J12 : "1"
>J : J<T, U>

declare const J22: J<2, 2>;
>J22 : never
>J : J<T, U>

declare const J11or2: J<1, 1 | 2>;
>J11or2 : "1"
>J : J<T, U>

declare const J1string: J<1, "">;
>J1string : "1"
>J : J<T, U>

declare const J1empty: J<1, {}>;
>J1empty : "1"
>J : J<T, U>

declare const J1never: J<1, never>;
>J1never : "1"
>J : J<T, U>

declare const J1any: J<1, any>;
>J1any : "1"
>J : J<T, U>

declare const J1undefined: J<1, undefined>;
>J1undefined : "1"
>J : J<T, U>

// union, one match, else
type K<T, U> = (T | U) match {
>K : K<T, U>
>T : T
>U : U
>T : T
>U : U

    1: "1",
    else: "else"
};
declare const K11: K<1, 1>;
>K11 : "1"
>K : K<T, U>

declare const K12: K<1, 2>;
>K12 : "else" | "1"
>K : K<T, U>

declare const K22: K<2, 2>;
>K22 : "else"
>K : K<T, U>

declare const K11or2: K<1, 1 | 2>;
>K11or2 : "else" | "1"
>K : K<T, U>

declare const K1string: K<1, "">;
>K1string : "else" | "1"
>K : K<T, U>

declare const K1empty: K<1, {}>;
>K1empty : "else" | "1"
>K : K<T, U>

declare const K1never: K<1, never>;
>K1never : "1"
>K : K<T, U>

declare const K1any: K<1, any>;
>K1any : "1"
>K : K<T, U>

declare const K1undefined: K<1, undefined>;
>K1undefined : "1"
>K : K<T, U>

