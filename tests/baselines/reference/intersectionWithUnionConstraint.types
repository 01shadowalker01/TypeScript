=== tests/cases/conformance/types/intersection/intersectionWithUnionConstraint.ts ===
function f1<T extends string | number, U extends string | number>(x: T & U) {
>f1 : <T extends string | number, U extends string | number>(x: T & U) => void
>T : T
>U : U
>x : T & U
>T : T
>U : U

    // Combined constraint of 'T & U' is 'string | number'
    let y: string | number = x;
>y : string | number
>x : T & U
}

function f2<T extends string | number | undefined, U extends string | null | undefined>(x: T & U) {
>f2 : <T extends string | number | undefined, U extends string | null | undefined>(x: T & U) => void
>T : T
>U : U
>null : null
>x : T & U
>T : T
>U : U

    let y1: string | number = x;     // Error
>y1 : string | number
>x : T & U

    let y2: string | null = x;       // Error
>y2 : string | null
>null : null
>x : T & U

    let y3: string | undefined = x;
>y3 : string | undefined
>x : T & U

    let y4: number | null = x;       // Error
>y4 : number | null
>null : null
>x : T & U

    let y5: number | undefined = x;  // Error
>y5 : number | undefined
>x : T & U

    let y6: null | undefined = x;    // Error
>y6 : null | undefined
>null : null
>x : T & U
}

type T1 = (string | number | undefined) & (string | null | undefined);  // string | undefined
>T1 : string | undefined
>null : null

// Repro from #23648

type Example<T, U> = { [K in keyof T]: K extends keyof U ? UnexpectedError<K> : NoErrorHere<K> }
>Example : Example<T, U>
>T : T
>U : U
>K : K
>T : T
>K : K
>U : U
>UnexpectedError : T
>K : K
>NoErrorHere : T
>K : K

type UnexpectedError<T extends PropertyKey> = T
>UnexpectedError : T
>T : T
>PropertyKey : string | number | symbol
>T : T

type NoErrorHere<T extends PropertyKey> = T
>NoErrorHere : T
>T : T
>PropertyKey : string | number | symbol
>T : T

