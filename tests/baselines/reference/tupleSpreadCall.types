=== tests/cases/conformance/types/tuple/tupleSpreadCall.ts ===
declare let singleton: [number]
>singleton : [number]

declare let pair: [number, number]
>pair : [number, number]

declare let wpair: [number, string]
>wpair : [number, string]

declare let triple: [number, number, number]
>triple : [number, number, number]

declare let ns: number[]
>ns : number[]

declare function one(n: number): void;
>one : (n: number) => void
>n : number

declare function two(n: number, m: number): void;
>two : (n: number, m: number) => void
>n : number
>m : number

declare function three(n: number, m: number, total: number): void;
>three : (n: number, m: number, total: number) => void
>n : number
>m : number
>total : number

declare function opt2(n: number, m?: number): void;
>opt2 : (n: number, m?: number) => void
>n : number
>m : number

declare function opt3(n: number, m: number, total?: number): void;
>opt3 : (n: number, m: number, total?: number) => void
>n : number
>m : number
>total : number

declare function rest(n: number, ...ns: number[]): void;
>rest : (n: number, ...ns: number[]) => void
>n : number
>ns : number[]

two(...pair)
>two(...pair) : void
>two : (n: number, m: number) => void
>...pair : number
>pair : [number, number]

two(...wpair) // wrong type
>two(...wpair) : void
>two : (n: number, m: number) => void
>...wpair : string | number
>wpair : [number, string]

three(1, ...pair)
>three(1, ...pair) : void
>three : (n: number, m: number, total: number) => void
>1 : 1
>...pair : number
>pair : [number, number]

three(1, ...wpair) // wrong type
>three(1, ...wpair) : void
>three : (n: number, m: number, total: number) => void
>1 : 1
>...wpair : string | number
>wpair : [number, string]

three(...pair, 1)
>three(...pair, 1) : void
>three : (n: number, m: number, total: number) => void
>...pair : number
>pair : [number, number]
>1 : 1

three(...wpair, 1) // wrong type
>three(...wpair, 1) : void
>three : (n: number, m: number, total: number) => void
>...wpair : string | number
>wpair : [number, string]
>1 : 1

// multiple spreads
three(...singleton, ...pair);
>three(...singleton, ...pair) : void
>three : (n: number, m: number, total: number) => void
>...singleton : number
>singleton : [number]
>...pair : number
>pair : [number, number]

three(...pair, ...singleton);
>three(...pair, ...singleton) : void
>three : (n: number, m: number, total: number) => void
>...pair : number
>pair : [number, number]
>...singleton : number
>singleton : [number]

three(12, ...singleton, ...singleton);
>three(12, ...singleton, ...singleton) : void
>three : (n: number, m: number, total: number) => void
>12 : 12
>...singleton : number
>singleton : [number]
>...singleton : number
>singleton : [number]

three(...singleton, 12, ...singleton);
>three(...singleton, 12, ...singleton) : void
>three : (n: number, m: number, total: number) => void
>...singleton : number
>singleton : [number]
>12 : 12
>...singleton : number
>singleton : [number]

three(...singleton, ...singleton, 12);
>three(...singleton, ...singleton, 12) : void
>three : (n: number, m: number, total: number) => void
>...singleton : number
>singleton : [number]
>...singleton : number
>singleton : [number]
>12 : 12

three(...wpair, ...singleton); // wrong type
>three(...wpair, ...singleton) : void
>three : (n: number, m: number, total: number) => void
>...wpair : string | number
>wpair : [number, string]
>...singleton : number
>singleton : [number]

three(...pair, ...pair); // Expected 3, got 4
>three(...pair, ...pair) : void
>three : (n: number, m: number, total: number) => void
>...pair : number
>pair : [number, number]
>...pair : number
>pair : [number, number]

// optionals (exact and inexact)
opt2(...pair);
>opt2(...pair) : void
>opt2 : (n: number, m?: number) => void
>...pair : number
>pair : [number, number]

opt2(1, ...singleton);
>opt2(1, ...singleton) : void
>opt2 : (n: number, m?: number) => void
>1 : 1
>...singleton : number
>singleton : [number]

opt2(...pair, 1); // Expected 1-2, got 3
>opt2(...pair, 1) : void
>opt2 : (n: number, m?: number) => void
>...pair : number
>pair : [number, number]
>1 : 1

opt2(...singleton);
>opt2(...singleton) : void
>opt2 : (n: number, m?: number) => void
>...singleton : number
>singleton : [number]

opt3(...singleton); // Expected 2-3, got 1
>opt3(...singleton) : void
>opt3 : (n: number, m: number, total?: number) => void
>...singleton : number
>singleton : [number]

opt3(...singleton, ...pair);
>opt3(...singleton, ...pair) : void
>opt3 : (n: number, m: number, total?: number) => void
>...singleton : number
>singleton : [number]
>...pair : number
>pair : [number, number]

// OK: arrays of any length are spreadable into optional arguments
opt2(...triple);
>opt2(...triple) : void
>opt2 : (n: number, m?: number) => void
>...triple : number
>triple : [number, number, number]

opt2(1, ...pair);
>opt2(1, ...pair) : void
>opt2 : (n: number, m?: number) => void
>1 : 1
>...pair : number
>pair : [number, number]

opt3(...singleton, 2, ...triple);
>opt3(...singleton, 2, ...triple) : void
>opt3 : (n: number, m: number, total?: number) => void
>...singleton : number
>singleton : [number]
>2 : 2
>...triple : number
>triple : [number, number, number]

opt3(2, ...triple);
>opt3(2, ...triple) : void
>opt3 : (n: number, m: number, total?: number) => void
>2 : 2
>...triple : number
>triple : [number, number, number]

opt3(2, ...singleton, ...triple);
>opt3(2, ...singleton, ...triple) : void
>opt3 : (n: number, m: number, total?: number) => void
>2 : 2
>...singleton : number
>singleton : [number]
>...triple : number
>triple : [number, number, number]

opt3(2, 3, ...triple);
>opt3(2, 3, ...triple) : void
>opt3 : (n: number, m: number, total?: number) => void
>2 : 2
>3 : 3
>...triple : number
>triple : [number, number, number]

opt3(...singleton, 2, ...ns);
>opt3(...singleton, 2, ...ns) : void
>opt3 : (n: number, m: number, total?: number) => void
>...singleton : number
>singleton : [number]
>2 : 2
>...ns : number
>ns : number[]

opt3(2, ...singleton, ...ns);
>opt3(2, ...singleton, ...ns) : void
>opt3 : (n: number, m: number, total?: number) => void
>2 : 2
>...singleton : number
>singleton : [number]
>...ns : number
>ns : number[]

// TODO: calls with rests (exact and inexact), overloads, generics

