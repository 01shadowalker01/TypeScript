=== tests/cases/conformance/types/tuple/tupleSpreadCall.ts ===
declare let singleton: [number]
>singleton : [number]

declare let pair: [number, number]
>pair : [number, number]

declare let wpair: [number, string]
>wpair : [number, string]

declare let triple: [number, number, number]
>triple : [number, number, number]

declare let ns: number[]
>ns : number[]

declare function two(n: number, m: number): void;
>two : (n: number, m: number) => void
>n : number
>m : number

declare function three(n: number, m: number, total: number): void;
>three : (n: number, m: number, total: number) => void
>n : number
>m : number
>total : number

declare function opt2(n: number, m?: number): void;
>opt2 : (n: number, m?: number) => void
>n : number
>m : number

declare function opt3(n: number, m: number, total?: number): void;
>opt3 : (n: number, m: number, total?: number) => void
>n : number
>m : number
>total : number

declare function rest(n: number, ...ns: number[]): void;
>rest : (n: number, ...ns: number[]) => void
>n : number
>ns : number[]

declare function rest2(n: number, m: number, ...ns: number[]): void;
>rest2 : (n: number, m: number, ...ns: number[]) => void
>n : number
>m : number
>ns : number[]

type First = { first }
>First : First
>first : any

type Second = { second }
>Second : Second
>second : any

declare function onetwo(n: number): First;
>onetwo : { (n: number): First; (n: number, m: number): Second; }
>n : number
>First : First

declare function onetwo(n: number, m: number): Second;
>onetwo : { (n: number): First; (n: number, m: number): Second; }
>n : number
>m : number
>Second : Second

declare function optwothree(n: number, m?: number): First;
>optwothree : { (n: number, m?: number): First; (n: number, m: number, total?: number): Second; }
>n : number
>m : number
>First : First

declare function optwothree(n: number, m: number, total?: number): Second;
>optwothree : { (n: number, m?: number): First; (n: number, m: number, total?: number): Second; }
>n : number
>m : number
>total : number
>Second : Second

two(...pair)
>two(...pair) : void
>two : (n: number, m: number) => void
>...pair : number
>pair : [number, number]

two(...wpair) // wrong type
>two(...wpair) : void
>two : (n: number, m: number) => void
>...wpair : string | number
>wpair : [number, string]

three(1, ...pair)
>three(1, ...pair) : void
>three : (n: number, m: number, total: number) => void
>1 : 1
>...pair : number
>pair : [number, number]

three(1, ...wpair) // wrong type
>three(1, ...wpair) : void
>three : (n: number, m: number, total: number) => void
>1 : 1
>...wpair : string | number
>wpair : [number, string]

three(...pair, 1)
>three(...pair, 1) : void
>three : (n: number, m: number, total: number) => void
>...pair : number
>pair : [number, number]
>1 : 1

three(...wpair, 1) // wrong type
>three(...wpair, 1) : void
>three : (n: number, m: number, total: number) => void
>...wpair : string | number
>wpair : [number, string]
>1 : 1

// multiple spreads
three(...singleton, ...pair);
>three(...singleton, ...pair) : void
>three : (n: number, m: number, total: number) => void
>...singleton : number
>singleton : [number]
>...pair : number
>pair : [number, number]

three(...pair, ...singleton);
>three(...pair, ...singleton) : void
>three : (n: number, m: number, total: number) => void
>...pair : number
>pair : [number, number]
>...singleton : number
>singleton : [number]

three(12, ...singleton, ...singleton);
>three(12, ...singleton, ...singleton) : void
>three : (n: number, m: number, total: number) => void
>12 : 12
>...singleton : number
>singleton : [number]
>...singleton : number
>singleton : [number]

three(...singleton, 12, ...singleton);
>three(...singleton, 12, ...singleton) : void
>three : (n: number, m: number, total: number) => void
>...singleton : number
>singleton : [number]
>12 : 12
>...singleton : number
>singleton : [number]

three(...singleton, ...singleton, 12);
>three(...singleton, ...singleton, 12) : void
>three : (n: number, m: number, total: number) => void
>...singleton : number
>singleton : [number]
>...singleton : number
>singleton : [number]
>12 : 12

three(...wpair, ...singleton); // wrong type
>three(...wpair, ...singleton) : void
>three : (n: number, m: number, total: number) => void
>...wpair : string | number
>wpair : [number, string]
>...singleton : number
>singleton : [number]

three(...pair, ...pair); // Expected 3, got 4
>three(...pair, ...pair) : void
>three : (n: number, m: number, total: number) => void
>...pair : number
>pair : [number, number]
>...pair : number
>pair : [number, number]

// optionals (exact and inexact)
opt2(...pair);
>opt2(...pair) : void
>opt2 : (n: number, m?: number) => void
>...pair : number
>pair : [number, number]

opt2(1, ...singleton);
>opt2(1, ...singleton) : void
>opt2 : (n: number, m?: number) => void
>1 : 1
>...singleton : number
>singleton : [number]

opt2(...pair, 1); // Expected 1-2, got 3
>opt2(...pair, 1) : void
>opt2 : (n: number, m?: number) => void
>...pair : number
>pair : [number, number]
>1 : 1

opt2(...singleton);
>opt2(...singleton) : void
>opt2 : (n: number, m?: number) => void
>...singleton : number
>singleton : [number]

opt3(...singleton); // Expected 2-3, got 1
>opt3(...singleton) : void
>opt3 : (n: number, m: number, total?: number) => void
>...singleton : number
>singleton : [number]

opt3(...singleton, ...pair);
>opt3(...singleton, ...pair) : void
>opt3 : (n: number, m: number, total?: number) => void
>...singleton : number
>singleton : [number]
>...pair : number
>pair : [number, number]

// OK: arrays of any length are spreadable into optional arguments
opt2(...triple);
>opt2(...triple) : void
>opt2 : (n: number, m?: number) => void
>...triple : number
>triple : [number, number, number]

opt2(1, ...pair);
>opt2(1, ...pair) : void
>opt2 : (n: number, m?: number) => void
>1 : 1
>...pair : number
>pair : [number, number]

opt3(...singleton, 2, ...triple);
>opt3(...singleton, 2, ...triple) : void
>opt3 : (n: number, m: number, total?: number) => void
>...singleton : number
>singleton : [number]
>2 : 2
>...triple : number
>triple : [number, number, number]

opt3(2, ...triple);
>opt3(2, ...triple) : void
>opt3 : (n: number, m: number, total?: number) => void
>2 : 2
>...triple : number
>triple : [number, number, number]

opt3(2, ...singleton, ...triple);
>opt3(2, ...singleton, ...triple) : void
>opt3 : (n: number, m: number, total?: number) => void
>2 : 2
>...singleton : number
>singleton : [number]
>...triple : number
>triple : [number, number, number]

opt3(2, 3, ...triple);
>opt3(2, 3, ...triple) : void
>opt3 : (n: number, m: number, total?: number) => void
>2 : 2
>3 : 3
>...triple : number
>triple : [number, number, number]

opt3(...singleton, 2, ...ns);
>opt3(...singleton, 2, ...ns) : void
>opt3 : (n: number, m: number, total?: number) => void
>...singleton : number
>singleton : [number]
>2 : 2
>...ns : number
>ns : number[]

opt3(2, ...singleton, ...ns);
>opt3(2, ...singleton, ...ns) : void
>opt3 : (n: number, m: number, total?: number) => void
>2 : 2
>...singleton : number
>singleton : [number]
>...ns : number
>ns : number[]

//calls with rests (exact and inexact)
rest(...pair);
>rest(...pair) : void
>rest : (n: number, ...ns: number[]) => void
>...pair : number
>pair : [number, number]

rest(1, ...pair);
>rest(1, ...pair) : void
>rest : (n: number, ...ns: number[]) => void
>1 : 1
>...pair : number
>pair : [number, number]

rest2(...singleton); // Expected at least 2, got 1
>rest2(...singleton) : void
>rest2 : (n: number, m: number, ...ns: number[]) => void
>...singleton : number
>singleton : [number]

rest2(...singleton, ...singleton);
>rest2(...singleton, ...singleton) : void
>rest2 : (n: number, m: number, ...ns: number[]) => void
>...singleton : number
>singleton : [number]
>...singleton : number
>singleton : [number]

rest2(...singleton, ...singleton, ...singleton);
>rest2(...singleton, ...singleton, ...singleton) : void
>rest2 : (n: number, m: number, ...ns: number[]) => void
>...singleton : number
>singleton : [number]
>...singleton : number
>singleton : [number]
>...singleton : number
>singleton : [number]

rest2(...singleton, ...singleton, ...triple);
>rest2(...singleton, ...singleton, ...triple) : void
>rest2 : (n: number, m: number, ...ns: number[]) => void
>...singleton : number
>singleton : [number]
>...singleton : number
>singleton : [number]
>...triple : number
>triple : [number, number, number]

// overloads
declare var first: First;
>first : First
>First : First

declare var second: Second;
>second : Second
>Second : Second

var first = onetwo(...singleton);
>first : First
>onetwo(...singleton) : First
>onetwo : { (n: number): First; (n: number, m: number): Second; }
>...singleton : number
>singleton : [number]

var second = onetwo(...pair);
>second : Second
>onetwo(...pair) : Second
>onetwo : { (n: number): First; (n: number, m: number): Second; }
>...pair : number
>pair : [number, number]

var second = onetwo(...triple); // Expected 1-2, got 3
>second : Second
>onetwo(...triple) : any
>onetwo : { (n: number): First; (n: number, m: number): Second; }
>...triple : number
>triple : [number, number, number]

var first = optwothree(...singleton);
>first : First
>optwothree(...singleton) : First
>optwothree : { (n: number, m?: number): First; (n: number, m: number, total?: number): Second; }
>...singleton : number
>singleton : [number]

var first = optwothree(...pair);
>first : First
>optwothree(...pair) : First
>optwothree : { (n: number, m?: number): First; (n: number, m: number, total?: number): Second; }
>...pair : number
>pair : [number, number]

var first = optwothree(...pair, ...singleton);
>first : First
>optwothree(...pair, ...singleton) : First
>optwothree : { (n: number, m?: number): First; (n: number, m: number, total?: number): Second; }
>...pair : number
>pair : [number, number]
>...singleton : number
>singleton : [number]

var second = optwothree(...pair, 1);
>second : Second
>optwothree(...pair, 1) : Second
>optwothree : { (n: number, m?: number): First; (n: number, m: number, total?: number): Second; }
>...pair : number
>pair : [number, number]
>1 : 1

var first = optwothree(...pair, ...pair);
>first : First
>optwothree(...pair, ...pair) : First
>optwothree : { (n: number, m?: number): First; (n: number, m: number, total?: number): Second; }
>...pair : number
>pair : [number, number]
>...pair : number
>pair : [number, number]

optwothree(...triple, 1); // expected 1-3, got 4
>optwothree(...triple, 1) : any
>optwothree : { (n: number, m?: number): First; (n: number, m: number, total?: number): Second; }
>...triple : number
>triple : [number, number, number]
>1 : 1

// TODO: generics

