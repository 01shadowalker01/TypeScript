=== tests/cases/conformance/types/match/matchNonGeneric.ts ===
// all of these test `match` in basic scenarios where we can eagerly compute the resulting type.

// empty
declare const A: 1 match {
>A : Symbol(A, Decl(matchNonGeneric.ts, 3, 13))

};

// only else
declare const B: 1 match {
>B : Symbol(B, Decl(matchNonGeneric.ts, 7, 13))

    else: "else"
};

// only one exact match, no else
declare const C: 1 match {
>C : Symbol(C, Decl(matchNonGeneric.ts, 12, 13))

    1: "1"
};

// only one subtype match, no else
declare const D: 1 match {
>D : Symbol(D, Decl(matchNonGeneric.ts, 17, 13))

    number: "number"
};

// multiple possible subtype matches, no else
declare const E: 1 match {
>E : Symbol(E, Decl(matchNonGeneric.ts, 22, 13))

    1 | 2: "1 | 2",
    number: "number"
};

// multiple possible matches (subtype match first), no else
declare const F: 1 match {
>F : Symbol(F, Decl(matchNonGeneric.ts, 28, 13))

    1 | 2: "1 | 2",
    1: "1",
    number: "number"
};

// no match, no else
declare const G: 1 match {
>G : Symbol(G, Decl(matchNonGeneric.ts, 35, 13))

    string: "string"
};

// no match, else
declare const H: 1 match {
>H : Symbol(H, Decl(matchNonGeneric.ts, 40, 13))

    string: "string",
    else: "else"
};

// union, both match, no else
declare const I: (1 | 2) match {
>I : Symbol(I, Decl(matchNonGeneric.ts, 46, 13))

    1: "1",
    2: "2"
};

// union, one match, no else
declare const J: (1 | 2) match {
>J : Symbol(J, Decl(matchNonGeneric.ts, 52, 13))

    1: "1"
};

// union, one match, else
declare const K: (1 | 2) match {
>K : Symbol(K, Decl(matchNonGeneric.ts, 57, 13))

    1: "1",
    else: "else"
};

