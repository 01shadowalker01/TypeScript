=== tests/cases/conformance/classes/propertyMemberDeclarations/derivedUninitializedPropertyDeclaration.ts ===
class A {
>A : Symbol(A, Decl(derivedUninitializedPropertyDeclaration.ts, 0, 0))

    property = 'x';
>property : Symbol(A.property, Decl(derivedUninitializedPropertyDeclaration.ts, 0, 9))

    m() { return 1 }
>m : Symbol(A.m, Decl(derivedUninitializedPropertyDeclaration.ts, 1, 19))
}
class B extends A {
>B : Symbol(B, Decl(derivedUninitializedPropertyDeclaration.ts, 3, 1))
>A : Symbol(A, Decl(derivedUninitializedPropertyDeclaration.ts, 0, 0))

    property: any; // error
>property : Symbol(B.property, Decl(derivedUninitializedPropertyDeclaration.ts, 4, 19))
}
class BD extends A {
>BD : Symbol(BD, Decl(derivedUninitializedPropertyDeclaration.ts, 6, 1))
>A : Symbol(A, Decl(derivedUninitializedPropertyDeclaration.ts, 0, 0))

    declare property: any; // ok because it's implicitly initialised
>property : Symbol(BD.property, Decl(derivedUninitializedPropertyDeclaration.ts, 7, 20))
}
class BDBang extends A {
>BDBang : Symbol(BDBang, Decl(derivedUninitializedPropertyDeclaration.ts, 9, 1))
>A : Symbol(A, Decl(derivedUninitializedPropertyDeclaration.ts, 0, 0))

    declare property!: any; // doesn't need !, but is still allowed
>property : Symbol(BDBang.property, Decl(derivedUninitializedPropertyDeclaration.ts, 10, 24))
}
class BOther extends A {
>BOther : Symbol(BOther, Decl(derivedUninitializedPropertyDeclaration.ts, 12, 1))
>A : Symbol(A, Decl(derivedUninitializedPropertyDeclaration.ts, 0, 0))

    declare m() { return 2 } // not allowed on methods
>m : Symbol(BOther.m, Decl(derivedUninitializedPropertyDeclaration.ts, 13, 24))

    declare nonce: any; // only allowed when exists in base
>nonce : Symbol(BOther.nonce, Decl(derivedUninitializedPropertyDeclaration.ts, 14, 28))

    declare property = 'y' // initialiser not allowed with declare
>property : Symbol(BOther.property, Decl(derivedUninitializedPropertyDeclaration.ts, 15, 23))
}
class U {
>U : Symbol(U, Decl(derivedUninitializedPropertyDeclaration.ts, 17, 1))

    declare nonce: any; // ambient declaration only allowed when an override
>nonce : Symbol(U.nonce, Decl(derivedUninitializedPropertyDeclaration.ts, 18, 9))
}

class C {
>C : Symbol(C, Decl(derivedUninitializedPropertyDeclaration.ts, 20, 1))

    p: string;
>p : Symbol(C.p, Decl(derivedUninitializedPropertyDeclaration.ts, 22, 9))
}
class D extends C {
>D : Symbol(D, Decl(derivedUninitializedPropertyDeclaration.ts, 24, 1))
>C : Symbol(C, Decl(derivedUninitializedPropertyDeclaration.ts, 20, 1))

    p: 'hi'; // error
>p : Symbol(D.p, Decl(derivedUninitializedPropertyDeclaration.ts, 25, 19))
}
class DD extends C {
>DD : Symbol(DD, Decl(derivedUninitializedPropertyDeclaration.ts, 27, 1))
>C : Symbol(C, Decl(derivedUninitializedPropertyDeclaration.ts, 20, 1))

    declare p: 'bye'; // ok
>p : Symbol(DD.p, Decl(derivedUninitializedPropertyDeclaration.ts, 28, 20))
}


declare class E {
>E : Symbol(E, Decl(derivedUninitializedPropertyDeclaration.ts, 30, 1))

    p1: string
>p1 : Symbol(E.p1, Decl(derivedUninitializedPropertyDeclaration.ts, 33, 17))

    p2: string
>p2 : Symbol(E.p2, Decl(derivedUninitializedPropertyDeclaration.ts, 34, 14))
}
class F extends E {
>F : Symbol(F, Decl(derivedUninitializedPropertyDeclaration.ts, 36, 1))
>E : Symbol(E, Decl(derivedUninitializedPropertyDeclaration.ts, 30, 1))

    p1!: 'z'
>p1 : Symbol(F.p1, Decl(derivedUninitializedPropertyDeclaration.ts, 37, 19))

    declare p2: 'alpha'
>p2 : Symbol(F.p2, Decl(derivedUninitializedPropertyDeclaration.ts, 38, 12))
}

