=== tests/cases/conformance/salsa/a.js ===
// TODO: JSDoc would provide a contextual type, so ... I should test that
//  (a number of existing tests fail because of that, I think)
// TODO: Try initializer of function or class I guess (though classes aren't context sensitive)
// TODO: Duplicated declarations should be OK (if they have the same type (??))
var my = my || {};
>my : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>my || {} : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>my : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>{} : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }

my.m = function() {
>my.m = function() {    return 1;} : () => number
>my.m : () => number
>my : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>m : () => number
>function() {    return 1;} : () => number

    return 1;
>1 : 1
}
my.n = 1;
>my.n = 1 : 1
>my.n : number
>my : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>n : number
>1 : 1

my.o = {};
>my.o = {} : { [x: string]: any; }
>my.o : { [x: string]: any; }
>my : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>o : { [x: string]: any; }
>{} : { [x: string]: any; }

my.predicate = my.predicate || {};
>my.predicate = my.predicate || {} : { [x: string]: any; query: { (): void; result: string; }; }
>my.predicate : { [x: string]: any; query: { (): void; result: string; }; }
>my : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>predicate : { [x: string]: any; query: { (): void; result: string; }; }
>my.predicate || {} : { [x: string]: any; query: { (): void; result: string; }; }
>my.predicate : { [x: string]: any; query: { (): void; result: string; }; }
>my : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>predicate : { [x: string]: any; query: { (): void; result: string; }; }
>{} : { [x: string]: any; query: { (): void; result: string; }; }

my.predicate.query = function () {
>my.predicate.query = function () {    var me = this;    me.property = false;} : { (): void; result: string; }
>my.predicate.query : { (): void; result: string; }
>my.predicate : { [x: string]: any; query: { (): void; result: string; }; }
>my : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>predicate : { [x: string]: any; query: { (): void; result: string; }; }
>query : { (): void; result: string; }
>function () {    var me = this;    me.property = false;} : { (): void; result: string; }

    var me = this;
>me : { [x: string]: any; query: { (): void; result: string; }; }
>this : { [x: string]: any; query: { (): void; result: string; }; }

    me.property = false;
>me.property = false : false
>me.property : any
>me : { [x: string]: any; query: { (): void; result: string; }; }
>property : any
>false : false

};
var q = new my.predicate.query();
>q : any
>new my.predicate.query() : any
>my.predicate.query : { (): void; result: string; }
>my.predicate : { [x: string]: any; query: { (): void; result: string; }; }
>my : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>predicate : { [x: string]: any; query: { (): void; result: string; }; }
>query : { (): void; result: string; }

my.predicate.query.result = 'none'
>my.predicate.query.result = 'none' : "none"
>my.predicate.query.result : string
>my.predicate.query : { (): void; result: string; }
>my.predicate : { [x: string]: any; query: { (): void; result: string; }; }
>my : { [x: string]: any; m: () => number; n: number; o: { [x: string]: any; }; predicate: { [x: string]: any; query: { (): void; result: string; }; }; }
>predicate : { [x: string]: any; query: { (): void; result: string; }; }
>query : { (): void; result: string; }
>result : string
>'none' : "none"

// my.predicate.sort = my.predicate.sort || function (first, second) {
    // return first;
// }

