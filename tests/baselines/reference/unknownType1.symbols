=== tests/cases/conformance/types/unknown/unknownType1.ts ===
// In an intersection everything absorbs unknown

type T00 = unknown & null;  // null
>T00 : Symbol(T00, Decl(unknownType1.ts, 0, 0))

type T01 = unknown & undefined;  // undefined
>T01 : Symbol(T01, Decl(unknownType1.ts, 2, 26))

type T02 = unknown & null & undefined;  // null & undefined (which becomes never in union)
>T02 : Symbol(T02, Decl(unknownType1.ts, 3, 31))

type T03 = unknown & string;  // string
>T03 : Symbol(T03, Decl(unknownType1.ts, 4, 38))

type T04 = unknown & string[];  // string[]
>T04 : Symbol(T04, Decl(unknownType1.ts, 5, 28))

type T05 = unknown & unknown;  // unknown
>T05 : Symbol(T05, Decl(unknownType1.ts, 6, 30))

type T06 = unknown & any;  // any
>T06 : Symbol(T06, Decl(unknownType1.ts, 7, 29))

// In a union an unknown absorbs everything

type T10 = unknown | null;  // unknown
>T10 : Symbol(T10, Decl(unknownType1.ts, 8, 25))

type T11 = unknown | undefined;  // unknown
>T11 : Symbol(T11, Decl(unknownType1.ts, 12, 26))

type T12 = unknown | null | undefined;  // unknown
>T12 : Symbol(T12, Decl(unknownType1.ts, 13, 31))

type T13 = unknown | string;  // unknown
>T13 : Symbol(T13, Decl(unknownType1.ts, 14, 38))

type T14 = unknown | string[];  // unknown
>T14 : Symbol(T14, Decl(unknownType1.ts, 15, 28))

type T15 = unknown | unknown;  // unknown
>T15 : Symbol(T15, Decl(unknownType1.ts, 16, 30))

type T16 = unknown | any;  // any
>T16 : Symbol(T16, Decl(unknownType1.ts, 17, 29))

// Type variable and unknown in union and intersection

type T20<T> = T & {};  // T & {}
>T20 : Symbol(T20, Decl(unknownType1.ts, 18, 25))
>T : Symbol(T, Decl(unknownType1.ts, 22, 9))
>T : Symbol(T, Decl(unknownType1.ts, 22, 9))

type T21<T> = T | {};  // T | {}
>T21 : Symbol(T21, Decl(unknownType1.ts, 22, 21))
>T : Symbol(T, Decl(unknownType1.ts, 23, 9))
>T : Symbol(T, Decl(unknownType1.ts, 23, 9))

type T22<T> = T & unknown;  // T
>T22 : Symbol(T22, Decl(unknownType1.ts, 23, 21))
>T : Symbol(T, Decl(unknownType1.ts, 24, 9))
>T : Symbol(T, Decl(unknownType1.ts, 24, 9))

type T23<T> = T | unknown;  // unknown
>T23 : Symbol(T23, Decl(unknownType1.ts, 24, 26))
>T : Symbol(T, Decl(unknownType1.ts, 25, 9))
>T : Symbol(T, Decl(unknownType1.ts, 25, 9))

// unknown in conditional types

type T30<T> = unknown extends T ? true : false;  // Deferred
>T30 : Symbol(T30, Decl(unknownType1.ts, 25, 26))
>T : Symbol(T, Decl(unknownType1.ts, 29, 9))
>T : Symbol(T, Decl(unknownType1.ts, 29, 9))

type T31<T> = T extends unknown ? true : false;  // true
>T31 : Symbol(T31, Decl(unknownType1.ts, 29, 47))
>T : Symbol(T, Decl(unknownType1.ts, 30, 9))
>T : Symbol(T, Decl(unknownType1.ts, 30, 9))

type T32<T> = never extends T ? true : false;  // true
>T32 : Symbol(T32, Decl(unknownType1.ts, 30, 47))
>T : Symbol(T, Decl(unknownType1.ts, 31, 9))
>T : Symbol(T, Decl(unknownType1.ts, 31, 9))

type T33<T> = T extends never ? true : false;  // Deferred
>T33 : Symbol(T33, Decl(unknownType1.ts, 31, 45))
>T : Symbol(T, Decl(unknownType1.ts, 32, 9))
>T : Symbol(T, Decl(unknownType1.ts, 32, 9))

// keyof unknown

type T40 = keyof any;  // string | number | symbol
>T40 : Symbol(T40, Decl(unknownType1.ts, 32, 45))

type T41 = keyof unknown;  // string | number | symbol
>T41 : Symbol(T41, Decl(unknownType1.ts, 36, 21))

// typeof, instanceof, and user defined type predicates

declare function isFunction(x: unknown): x is Function;
>isFunction : Symbol(isFunction, Decl(unknownType1.ts, 37, 25))
>x : Symbol(x, Decl(unknownType1.ts, 41, 28))
>x : Symbol(x, Decl(unknownType1.ts, 41, 28))
>Function : Symbol(Function, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))

function f1(x: unknown) {
>f1 : Symbol(f1, Decl(unknownType1.ts, 41, 55))
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))

    if (typeof x === "string" || typeof x === "number") {
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))

        x;  // string | number
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))
    }
    if (typeof x === "object") {
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))

        x;  // object
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))
    }
    if (typeof x === "function") {
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))

        x;  // object
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))
    }
    if (x instanceof Error) {
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))
>Error : Symbol(Error, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))

        x;  // Error
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))
    }
    if (isFunction(x)) {
>isFunction : Symbol(isFunction, Decl(unknownType1.ts, 37, 25))
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))

        x;  // Function
>x : Symbol(x, Decl(unknownType1.ts, 43, 12))
    }
}

// Homomorphic mapped type over unknown

type T50<T> = { [P in keyof T]: number };
>T50 : Symbol(T50, Decl(unknownType1.ts, 59, 1))
>T : Symbol(T, Decl(unknownType1.ts, 63, 9))
>P : Symbol(P, Decl(unknownType1.ts, 63, 17))
>T : Symbol(T, Decl(unknownType1.ts, 63, 9))

type T51 = T50<unknown>;  // { [x: string]: number }
>T51 : Symbol(T51, Decl(unknownType1.ts, 63, 41))
>T50 : Symbol(T50, Decl(unknownType1.ts, 59, 1))

type T52 = T50<any>;  // { [x: string]: number }
>T52 : Symbol(T52, Decl(unknownType1.ts, 64, 24))
>T50 : Symbol(T50, Decl(unknownType1.ts, 59, 1))

// Anything is assignable to unknown

function f2<T>(pAny: any, pNever: never, pT: T) {
>f2 : Symbol(f2, Decl(unknownType1.ts, 65, 20))
>T : Symbol(T, Decl(unknownType1.ts, 69, 12))
>pAny : Symbol(pAny, Decl(unknownType1.ts, 69, 15))
>pNever : Symbol(pNever, Decl(unknownType1.ts, 69, 25))
>pT : Symbol(pT, Decl(unknownType1.ts, 69, 40))
>T : Symbol(T, Decl(unknownType1.ts, 69, 12))

    let x: unknown;
>x : Symbol(x, Decl(unknownType1.ts, 70, 7))

    x = 123;
>x : Symbol(x, Decl(unknownType1.ts, 70, 7))

    x = "hello";
>x : Symbol(x, Decl(unknownType1.ts, 70, 7))

    x = [1, 2, 3];
>x : Symbol(x, Decl(unknownType1.ts, 70, 7))

    x = new Error();
>x : Symbol(x, Decl(unknownType1.ts, 70, 7))
>Error : Symbol(Error, Decl(lib.d.ts, --, --), Decl(lib.d.ts, --, --))

    x = x;
>x : Symbol(x, Decl(unknownType1.ts, 70, 7))
>x : Symbol(x, Decl(unknownType1.ts, 70, 7))

    x = pAny;
>x : Symbol(x, Decl(unknownType1.ts, 70, 7))
>pAny : Symbol(pAny, Decl(unknownType1.ts, 69, 15))

    x = pNever;
>x : Symbol(x, Decl(unknownType1.ts, 70, 7))
>pNever : Symbol(pNever, Decl(unknownType1.ts, 69, 25))

    x = pT;
>x : Symbol(x, Decl(unknownType1.ts, 70, 7))
>pT : Symbol(pT, Decl(unknownType1.ts, 69, 40))
}

// unknown assignable only to itself and any

function f3(x: unknown) {
>f3 : Symbol(f3, Decl(unknownType1.ts, 79, 1))
>x : Symbol(x, Decl(unknownType1.ts, 83, 12))

    let v1: any = x;
>v1 : Symbol(v1, Decl(unknownType1.ts, 84, 7))
>x : Symbol(x, Decl(unknownType1.ts, 83, 12))

    let v2: unknown = x;
>v2 : Symbol(v2, Decl(unknownType1.ts, 85, 7))
>x : Symbol(x, Decl(unknownType1.ts, 83, 12))

    let v3: object = x;  // Error
>v3 : Symbol(v3, Decl(unknownType1.ts, 86, 7))
>x : Symbol(x, Decl(unknownType1.ts, 83, 12))

    let v4: string = x;  // Error
>v4 : Symbol(v4, Decl(unknownType1.ts, 87, 7))
>x : Symbol(x, Decl(unknownType1.ts, 83, 12))

    let v5: string[] = x;  // Error
>v5 : Symbol(v5, Decl(unknownType1.ts, 88, 7))
>x : Symbol(x, Decl(unknownType1.ts, 83, 12))

    let v6: {} = x;  // Error
>v6 : Symbol(v6, Decl(unknownType1.ts, 89, 7))
>x : Symbol(x, Decl(unknownType1.ts, 83, 12))

    let v7: {} | null | undefined = x;  // Error
>v7 : Symbol(v7, Decl(unknownType1.ts, 90, 7))
>x : Symbol(x, Decl(unknownType1.ts, 83, 12))
}

// Type parameter 'T extends unknown' not related to object

function f4<T extends unknown>(x: T) {
>f4 : Symbol(f4, Decl(unknownType1.ts, 91, 1))
>T : Symbol(T, Decl(unknownType1.ts, 95, 12))
>x : Symbol(x, Decl(unknownType1.ts, 95, 31))
>T : Symbol(T, Decl(unknownType1.ts, 95, 12))

    let y: object = x;  // Error
>y : Symbol(y, Decl(unknownType1.ts, 96, 7))
>x : Symbol(x, Decl(unknownType1.ts, 95, 31))
}

// Anything but primitive assignable to { [x: string]: unknown }

function f5(x: { [x: string]: unknown }) {
>f5 : Symbol(f5, Decl(unknownType1.ts, 97, 1))
>x : Symbol(x, Decl(unknownType1.ts, 101, 12))
>x : Symbol(x, Decl(unknownType1.ts, 101, 18))

    x = {};
>x : Symbol(x, Decl(unknownType1.ts, 101, 12))

    x = { a: 5 };
>x : Symbol(x, Decl(unknownType1.ts, 101, 12))
>a : Symbol(a, Decl(unknownType1.ts, 103, 9))

    x = [1, 2, 3];
>x : Symbol(x, Decl(unknownType1.ts, 101, 12))

    x = 123;  // Error
>x : Symbol(x, Decl(unknownType1.ts, 101, 12))
}

// Locals of type unknown always considered initialized

function f6() {
>f6 : Symbol(f6, Decl(unknownType1.ts, 106, 1))

    let x: unknown;
>x : Symbol(x, Decl(unknownType1.ts, 111, 7))

    let y = x;
>y : Symbol(y, Decl(unknownType1.ts, 112, 7))
>x : Symbol(x, Decl(unknownType1.ts, 111, 7))
}

// Spread of unknown causes result to be unknown

function f7(x: {}, y: unknown, z: any) {
>f7 : Symbol(f7, Decl(unknownType1.ts, 113, 1))
>x : Symbol(x, Decl(unknownType1.ts, 117, 12))
>y : Symbol(y, Decl(unknownType1.ts, 117, 18))
>z : Symbol(z, Decl(unknownType1.ts, 117, 30))

    let o1 = { a: 42, ...x };  // { a: number }
>o1 : Symbol(o1, Decl(unknownType1.ts, 118, 7))
>a : Symbol(a, Decl(unknownType1.ts, 118, 14))
>x : Symbol(x, Decl(unknownType1.ts, 117, 12))

    let o2 = { a: 42, ...x, ...y };  // unknown
>o2 : Symbol(o2, Decl(unknownType1.ts, 119, 7))
>a : Symbol(a, Decl(unknownType1.ts, 119, 14))
>x : Symbol(x, Decl(unknownType1.ts, 117, 12))
>y : Symbol(y, Decl(unknownType1.ts, 117, 18))

    let o3 = { a: 42, ...x, ...y, ...z };  // any
>o3 : Symbol(o3, Decl(unknownType1.ts, 120, 7))
>a : Symbol(a, Decl(unknownType1.ts, 120, 14))
>x : Symbol(x, Decl(unknownType1.ts, 117, 12))
>y : Symbol(y, Decl(unknownType1.ts, 117, 18))
>z : Symbol(z, Decl(unknownType1.ts, 117, 30))
}

// Functions with unknown return type don't need return expressions

function f8(): unknown {
>f8 : Symbol(f8, Decl(unknownType1.ts, 121, 1))
}

// Class properties of type unknown don't need definite assignment

class C1 {
>C1 : Symbol(C1, Decl(unknownType1.ts, 126, 1))

    a: string;  // Error
>a : Symbol(C1.a, Decl(unknownType1.ts, 130, 10))

    b: unknown;
>b : Symbol(C1.b, Decl(unknownType1.ts, 131, 14))

    c: any;
>c : Symbol(C1.c, Decl(unknownType1.ts, 132, 15))
}

